From 3fac4cfacd1fda7b71473a0822ffba54e24c8a83 Mon Sep 17 00:00:00 2001
From: debbuild <debbuild>
Date: Thu, 6 Apr 2023 19:55:32 +0200
Subject: [PATCH 18/41] Issue #7: Move more stuff to header files.

Applying some simple rules from John Lakos greatly improves the
interconnectedness of the SGB library modules.

* Each module should #include its own interface (header file) as the
  first non-trivial code line; this guarantees that the code in the
  header file compiles stand-alone.
* In order to avoid double definitions, the contents of each header file
  should be wrapped in distinct include guards.
* Looking through the relevant sections in the final codes helps to
  separate internal preprocessor stuff (@d) from external stuff
  (#define); this leaves several @(...@> sections empty.

Replacing the ubiquitous #include "gb_graph.h" in the header files with
forward declarations is left as an exercise to the reader.
---
 PROTOTYPES/gb_basic.ch    | 41 +++++++++++++++++++
 PROTOTYPES/gb_books.ch    | 45 +++++++++++++++++++++
 PROTOTYPES/gb_dijk.ch     | 34 ++++++++++++++++
 PROTOTYPES/gb_econ.ch     | 35 ++++++++++++++++
 PROTOTYPES/gb_flip.ch     | 37 ++++++++++++++++-
 PROTOTYPES/gb_games.ch    | 85 +++++++++++++++++++++++++++++++++++++++
 PROTOTYPES/gb_gates.ch    | 74 +++++++++++++++++++++++++++++++++-
 PROTOTYPES/gb_graph.ch    | 68 ++++++++++++++++++++++++++++++-
 PROTOTYPES/gb_io.ch       | 55 +++++++++++++++++++++++--
 PROTOTYPES/gb_lisa.ch     | 38 ++++++++++++++++-
 PROTOTYPES/gb_miles.ch    | 31 ++++++++++++++
 PROTOTYPES/gb_plane.ch    | 38 ++++++++++++++++-
 PROTOTYPES/gb_raman.ch    | 10 +++++
 PROTOTYPES/gb_rand.ch     | 20 +++++++++
 PROTOTYPES/gb_roget.ch    | 34 +++++++++++++++-
 PROTOTYPES/gb_save.ch     | 19 ++++++++-
 PROTOTYPES/gb_sort.ch     | 24 ++++++++++-
 PROTOTYPES/gb_words.ch    | 30 ++++++++++++++
 PROTOTYPES/test_sample.ch | 14 +++++++
 19 files changed, 718 insertions(+), 14 deletions(-)

diff --git a/PROTOTYPES/gb_basic.ch b/PROTOTYPES/gb_basic.ch
index e42ed98..f6cfe26 100644
--- a/PROTOTYPES/gb_basic.ch
+++ b/PROTOTYPES/gb_basic.ch
@@ -13,6 +13,11 @@ extern Graph *lines(); /* the line graph of a graph */
 extern Graph *product(); /* the product of two graphs */
 extern Graph *induced(); /* a graph induced from another */
 @y
+#ifndef GB_BASIC_H
+#define GB_BASIC_H
+@#
+#include "gb_graph.h" /* we use the {\sc GB\_\,GRAPH} data structures */
+@#
 extern Graph *board(long,long,long,long,long,long,long);
    /* moves on generalized chessboards */
 extern Graph *simplex(unsigned long,long,long,long,long,long,long);
@@ -40,6 +45,12 @@ extern Graph *induced(Graph *,char *,long,long,long);
    /* a graph induced from another */
 @z
 
+@x l.33
+#include "gb_graph.h" /* we use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_basic.h" /* we use our own interface first */
+@z
+
 @x l.176
 Graph *board(n1,n2,n3,n4,piece,wrap,directed)
   long n1,n2,n3,n4; /* size of board desired */
@@ -362,6 +373,17 @@ Graph *lines(
     } while (v->u.V==u->v.V);
 @z
 
+@x l.2005
+@(gb_basic.h@>=
+#define cartesian 0
+#define direct 1
+#define strong 2
+@y
+@d cartesian 0
+@d direct 1
+@d strong 2
+@z
+
 @x l.2010
 Graph *product(g,gg,type,directed)
   Graph *g,*gg; /* graphs to be multiplied */
@@ -381,6 +403,15 @@ Graph *product(
   if (g==NULL || gg==NULL) panic(missing_operand); /* where are |g| and |gg|? */
 @z
 
+@x l.2161
+@d ind z.I
+
+@(gb_basic.h@>=
+#define ind @[z.I /* utility field |z| when used to induce a graph */@]
+@y
+@d ind z.I /* utility field |z| when used to induce a graph */@]
+@z
+
 @x l.2170
 Graph *bi_complete(n1,n2,directed)
   unsigned long n1; /* size of first part */
@@ -393,6 +424,14 @@ Graph *bi_complete(
   long directed) /* should all arcs go from first part to second? */
 @z
 
+@x l.2213
+@(gb_basic.h@>=
+#define IND_GRAPH 1000000000
+#define subst @[y.G@]
+
+@y
+@z
+
 @x l.2223
 Graph *wheel(n,n1,directed)
   unsigned long n; /* size of the rim */
@@ -412,6 +451,8 @@ extern Graph *wheel(); /* standard applications of |induced| */
 extern Graph *bi_complete(unsigned long,unsigned long,long);
 extern Graph *wheel(unsigned long,unsigned long,long);
    /* standard applications of |induced| */
+@#
+#endif /* |GB_BASIC_H| */
 @z
 
 @x l.2248
diff --git a/PROTOTYPES/gb_books.ch b/PROTOTYPES/gb_books.ch
index a69fdd0..3fa9302 100644
--- a/PROTOTYPES/gb_books.ch
+++ b/PROTOTYPES/gb_books.ch
@@ -2,12 +2,27 @@
 extern Graph *book();
 extern Graph *bi_book();
 @y
+#ifndef GB_BOOKS_H
+#define GB_BOOKS_H
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
 extern Graph *book(char *,unsigned long,unsigned long,@|
    unsigned long,unsigned long,long,long,long);
 extern Graph *bi_book(char *,unsigned long,unsigned long,@|
   unsigned long,unsigned long,long,long,long);
 @z
 
+@x l.148
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h" /* we will use the {\sc GB\_\,FLIP} routines
+                        for random numbers */
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_books.h" /* we use our own interface first */
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h" /* we will use the {\sc GB\_\,FLIP} routines
+                        for random numbers */
+@z
+
 @x l.158
 static Graph *bgraph(bipartite,
     title,n,x,first_chapter,last_chapter,in_weight,out_weight,seed)
@@ -64,6 +79,29 @@ register long j; /* all-purpose indices */
 register unsigned long k; /* all-purpose indices */
 @z
 
+@x l.306
+@d desc z.S /* utility field |z| points to the \<description> string */
+@d in_count y.I /* utility field |y| counts appearances in selected chapters */
+@d out_count x.I /* utility field |x| counts appearances in other chapters */
+@d short_code u.I /* utility field |u| contains a radix-36 number */
+
+@y
+@z
+
+@x l.335
+#define desc @t\quad@> z.S /* utility field definitions for the header file */
+#define in_count @t\quad@> y.I
+#define out_count @t\quad@> x.I
+#define short_code @t\quad@> u.I
+@y
+#define desc @t\quad@> z.S /* utility field |z| points to the \<description> string */
+#define in_count @t\quad@> y.I /* utility field |y| counts appearances in selected chapters */
+#define out_count @t\quad@> x.I /* utility field |x| counts appearances in other chapters */
+#define short_code @t\quad@> u.I /* utility field |u| contains a radix-36 number */
+@#
+#endif /* |GB_BOOKS_H| */
+@z
+
 @x l.377
     if (p->chap!=k) {
 @y
@@ -94,6 +132,13 @@ Vertex *chap_base=0;
       } while (c==','); /* repeat until end of the clique */
 @z
 
+@x l.471
+@ @(gb_books.h@>=
+#define chap_no @[a.I@] /* utility field definition in the header file */
+@y
+@ (This section remains empty for historic reasons.)
+@z
+
 @x l.499
 if (n>characters) n=characters;
 if (x>n) x=n;
diff --git a/PROTOTYPES/gb_dijk.ch b/PROTOTYPES/gb_dijk.ch
index 4e66730..bf8b289 100644
--- a/PROTOTYPES/gb_dijk.ch
+++ b/PROTOTYPES/gb_dijk.ch
@@ -1,8 +1,19 @@
+@x l.58
+#include "gb_graph.h" /* define the standard GraphBase data structures */
+@y
+#include "gb_dijk.h" /* we use our own interface first */
+@z
+
 @x l.68
+@(gb_dijk.h@>=
 extern long dijkstra(); /* procedure to calculate shortest paths */
 #define print_dijkstra_result p_dijkstra_result /* shorthand for linker */
 extern void print_dijkstra_result(); /* procedure to display the answer */
 @y
+@(gb_dijk.h@>=
+#ifndef GB_DIJK_H
+#define GB_DIJK_H
+#include "gb_graph.h" /* define the standard GraphBase data structures */
 extern long dijkstra(Vertex *,Vertex *,Graph *,long (*)(Vertex *));
    /* procedure to calculate shortest paths */
 #define print_dijkstra_result p_dijkstra_result /* shorthand for linker */
@@ -10,6 +21,14 @@ extern void print_dijkstra_result(Vertex *);
    /* procedure to display the answer */
 @z
 
+@x l.118
+@(gb_dijk.h@>=
+#define dist @[z.I@]
+#define backlink @[y.V@]
+
+@y
+@z
+
 @x l.143
 extern void @[@] (*init_queue)();
  /* create an empty priority queue for |dijkstra| */
@@ -27,6 +46,13 @@ extern Vertex *(*del_min)(void);
    /* remove an element with smallest key */
 @z
 
+@x l.155
+@(gb_dijk.h@>=
+#define hh_val @[x.I@]
+
+@y
+@z
+
 @x l.162
 static long dummy(v)
   Vertex *v;
@@ -51,6 +77,12 @@ long dijkstra(
   long @[@] (*hh)(Vertex *)) /* heuristic function */
 @z
 
+@x l.254
+@d print_dijkstra_result p_dijkstra_result /* shorthand for linker */
+
+@y
+@z
+
 @x l.257
 void print_dijkstra_result(vv)
   Vertex *vv; /* ending vertex */
@@ -191,4 +223,6 @@ extern void init_128(long);
 extern Vertex *del_128(void);
 extern void enq_128(Vertex *,long);
 extern void req_128(Vertex *,long);
+@#
+#endif /* |GB_DIJK_H| */
 @z
diff --git a/PROTOTYPES/gb_econ.ch b/PROTOTYPES/gb_econ.ch
index 2d9b95e..55cc5d5 100644
--- a/PROTOTYPES/gb_econ.ch
+++ b/PROTOTYPES/gb_econ.ch
@@ -1,9 +1,44 @@
 @x l.14
 extern Graph *econ();
 @y
+#ifndef GB_ECON_H
+#define GB_ECON_H
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
 extern Graph *econ(unsigned long,unsigned long,unsigned long,long);
 @z
 
+@x l.72
+@d flow a.I /* utility field |a| specifies the flow in an arc */
+@y
+@(gb_econ.h@>=
+#define flow @t\quad@> a.I /* utility field |a| specifies the flow in an arc */
+@#
+#endif /* |GB_ECON_H| */
+@z
+
+@x l.162
+@(gb_econ.h@>=
+#define flow @t\quad@> a.I
+   /* definitions of utility fields in the header file */
+#define SIC_codes @t\quad@> z.A
+#define sector_total @t\quad@> y.I
+
+@y
+@z
+
+@x l.181
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+#include "gb_graph.h"
+ /* and of course we'll use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_econ.h" /* we use our own interface first */
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+@z
+
 @x l.190
 Graph *econ(n,omit,threshold,seed)
   unsigned long n; /* number of vertices desired */
diff --git a/PROTOTYPES/gb_flip.ch b/PROTOTYPES/gb_flip.ch
index 1a84435..83038dd 100644
--- a/PROTOTYPES/gb_flip.ch
+++ b/PROTOTYPES/gb_flip.ch
@@ -4,7 +4,28 @@ int main()
 int main(void)
 @z
 
-@x l.98
+@x l.57
+@<Private declarations@>@;
+@y
+#include "gb_flip.h" /* we use our own interface first */
+@<Private declarations@>@;
+@z
+
+@x l.101
+@d gb_next_rand() (*gb_fptr>=0? *gb_fptr--: gb_flip_cycle())
+
+@y
+@z
+
+@x l.103
+@(gb_flip.h@>=
+@y
+@(gb_flip.h@>=
+#ifndef GB_FLIP_H
+#define GB_FLIP_H
+@z
+
+@x l.106
 extern long gb_flip_cycle(); /* compute 55 more pseudo-random numbers */
 @y
 extern long gb_flip_cycle(void); /* compute 55 more pseudo-random numbers */
@@ -25,6 +46,18 @@ void gb_init_rand(
 @z
 
 @x l.223
+@<Get the array...@>=
+(void) gb_flip_cycle();
+(void) gb_flip_cycle();
+(void) gb_flip_cycle();
+@y
+@<Get the array...@>=
+(void) gb_flip_cycle();
+(void) gb_flip_cycle();
+(void) gb_flip_cycle();@/
+@z
+
+@x l.230
 extern void gb_init_rand();
 @y
 extern void gb_init_rand(long);
@@ -54,4 +87,6 @@ long gb_unif_rand(
 extern long gb_unif_rand();
 @y
 extern long gb_unif_rand(long);
+@#
+#endif /* |GB_FLIP_H| */
 @z
diff --git a/PROTOTYPES/gb_games.ch b/PROTOTYPES/gb_games.ch
index b144669..20905c7 100644
--- a/PROTOTYPES/gb_games.ch
+++ b/PROTOTYPES/gb_games.ch
@@ -1,9 +1,86 @@
 @x l.14
 extern Graph *games();
 @y
+#ifndef GB_GAMES_H
+#define GB_GAMES_H
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
 extern Graph *games(unsigned long,long,long,long,long,long,long,long);
 @z
 
+@x l.90
+@d MAX_N 120
+@d MAX_DAY 128
+@d MAX_WEIGHT 131072
+@d ap u.I /* Associated Press scores: |(ap0<<16)+ap1| */
+@d upi v.I /* United Press International scores |(upi0<<16)+upi1| */
+@y
+@d MAX_N 120
+@d MAX_DAY 128
+@d MAX_WEIGHT 131072
+
+@(gb_games.h@>=
+#define ap @[u.I@] /* Associated Press scores: |(ap0<<16)+ap1| */
+#define upi @[v.I@] /* United Press International scores |(upi0<<16)+upi1| */
+@z
+
+@x l.112
+@d conference z.S
+@y
+@(gb_games.h@>=
+#define conference @[z.S@]
+@z
+
+@x l.124
+@d nickname y.S
+@d abbr x.S
+@y
+@(gb_games.h@>=
+#define abbr @[x.S@]
+#define nickname @[y.S@]
+@z
+
+@x l.134
+@d HOME 1
+@d NEUTRAL 2 /* this value is halfway between |HOME| and |AWAY| */
+@d AWAY 3
+@d venue a.I
+@d date b.I
+
+@y
+@z
+
+@x l.141
+#define ap @[u.I@] /* repeat the definitions in the header file */
+#define upi @[v.I@]
+#define abbr @[x.S@]
+#define nickname @[y.S@]
+#define conference @[z.S@]
+#define HOME 1
+#define NEUTRAL 2
+#define AWAY 3
+#define venue @[a.I@]
+#define date @[b.I@]
+@y
+#define HOME 1
+#define NEUTRAL 2
+#define AWAY 3
+#define date @[b.I@]
+@#
+#endif /* |GB_GAMES_H| */
+@z
+
+@x l.164
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_games.h" /* we use our own interface first */
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+@z
+
 @x l.174
 Graph *games(n,ap0_weight,upi0_weight,ap1_weight,upi1_weight,
      first_day,last_day,seed)
@@ -32,3 +109,11 @@ static Vertex *team_lookup() /* read and decode an abbreviation */
 @y
 static Vertex *team_lookup(void) /* read and decode an abbreviation */
 @z
+
+@x l.459
+@<Enter a new edge@>=
+@y
+@d venue a.I
+
+@<Enter a new edge@>=
+@z
diff --git a/PROTOTYPES/gb_gates.ch b/PROTOTYPES/gb_gates.ch
index 10c5329..db9a0fa 100644
--- a/PROTOTYPES/gb_gates.ch
+++ b/PROTOTYPES/gb_gates.ch
@@ -1,4 +1,5 @@
-@x l.27
+@x l.26
+#define print_gates p_gates /* abbreviation for Procrustean linkers */
 extern Graph *risc(); /* make a network for a microprocessor */
 extern Graph *prod(); /* make a network for high-speed multiplication */
 extern void print_gates(); /* write a network to standard output file */
@@ -6,6 +7,10 @@ extern long gate_eval(); /* evaluate a network */
 extern Graph *partial_gates(); /* reduce network size */
 extern long run_risc(); /* simulate the microprocessor */
 @y
+#ifndef GB_GATES_H
+#define GB_GATES_H
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
+#define print_gates p_gates /* abbreviation for Procrustean linkers */
 extern Graph *risc(unsigned long);
    /* make a network for a microprocessor */
 extern Graph *prod(unsigned long,unsigned long);
@@ -20,6 +25,50 @@ extern long run_risc(Graph *,unsigned long [],unsigned long,unsigned long);
    /* simulate the microprocessor */
 @z
 
+@x l.87
+@d val x.I /* the field containing a boolean value */
+@d typ y.I /* the field containing the gate type */
+@d alt z.V /* the field pointing to another related gate */
+@d outs zz.A /* the field pointing to the list of output gates */
+@d is_boolean(v) ((unsigned long)(v)<=1) /* is a |tip| field constant? */
+@d the_boolean(v) ((long)(v)) /* if so, this is its value */
+@d tip_value(v) (is_boolean(v)? the_boolean(v): (v)->val)
+@d AND '&'
+@d OR '|'
+@d NOT '~'
+@d XOR '^'
+
+@y
+@z
+
+@x l.100
+#define val @t\quad@> x.I /* the definitions are repeated in the header file */
+#define typ @t\quad@> y.I
+#define alt @t\quad@> z.V
+#define outs @t\quad@> zz.A
+#define is_boolean(v) @t\quad@> ((unsigned long)(v)<=1)
+#define the_boolean(v) @t\quad@> ((long)(v))
+#define tip_value(v) @t\quad@> (is_boolean(v)? the_boolean(v): (v)->val)
+#define AND @t\quad@> '&'
+#define OR @t\quad@> '|'
+#define NOT @t\quad@> '~'
+#define XOR @t\quad@> '^'
+@y
+#define val @t\quad@> x.I /* the field containing a boolean value */
+#define typ @t\quad@> y.I /* the field containing the gate type */
+#define alt @t\quad@> z.V /* the field pointing to another related gate */
+#define outs @t\quad@> zz.A /* the field pointing to the list of output gates */
+#define is_boolean(v) @t\quad@> ((unsigned long)(v)<=1) /* is a |tip| field constant? */
+#define the_boolean(v) @t\quad@> ((long)(v)) /* if so, this is its value */
+#define tip_value(v) @t\quad@> (is_boolean(v)? the_boolean(v): (v)->val)
+#define AND @t\quad@> '&'
+#define OR @t\quad@> '|'
+#define NOT @t\quad@> '~'
+#define XOR @t\quad@> '^'
+@#
+#endif /* |GB_GATES_H| */
+@z
+
 @x l.130
 long gate_eval(g,in_vec,out_vec)
   Graph *g; /* graph with gates as vertices */
@@ -32,6 +81,17 @@ long gate_eval(
   char *out_vec) /* string for output values, or |NULL| */
 @z
 
+@x l.184
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+#include "gb_graph.h"
+ /* and we will use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_gates.h" /* we use our own interface first */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+@z
+
 @x l.215
 Graph *risc(regs)
   unsigned long regs; /* number of registers supported */
@@ -181,6 +241,11 @@ long run_risc(
   for (r=0;r<trace_regs;r++) printf(" r%-2lu ",r); /* register names */
 @z
 
+@x l.1094
+@d print_gates p_gates /* abbreviation makes chopped-off name unique */
+@y
+@z
+
 @x l.1097
 static void pr_gate(v)
   Vertex *v;
@@ -203,6 +268,13 @@ void print_gates(
   Graph *g)
 @z
 
+@x l.1127
+@ @(gb_gates.h@>=
+#define bit @t\quad@> z.I
+@y
+@ (This section remains empty for historic reasons.)
+@z
+
 @x l.1146
 static Graph* reduce(g)
   Graph *g;
diff --git a/PROTOTYPES/gb_graph.ch b/PROTOTYPES/gb_graph.ch
index 2f70d63..1cd7d0a 100644
--- a/PROTOTYPES/gb_graph.ch
+++ b/PROTOTYPES/gb_graph.ch
@@ -4,6 +4,52 @@ int main()
 int main(void)
 @z
 
+@x l.43
+#ifdef SYSV
+#include <string.h>
+#else
+#include <strings.h>
+#endif
+#include <stdio.h>
+#include <stdlib.h>
+@h@#
+@<Type declarations@>@;
+@y
+#include "gb_graph.h" /* we include our own interface first */
+@h@#
+@z
+
+@x l.64
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef SYSV
+#include <string.h>
+#else
+#include <strings.h>
+#endif
+#undef min
+@y
+#ifndef GB_GRAPH_H
+#define GB_GRAPH_H
+@#
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef SYSV
+#include <string.h>
+#else
+#include <strings.h>
+#endif
+#undef min
+@z
+
+@x l.221
+@d gb_typed_alloc(n,t,s) @[(t*)@]gb_alloc((long)((n)*@[sizeof@](t)),s)
+@y
+@(gb_graph.h@>=
+#define gb_typed_alloc(n,t,s) @[@t\quad@>\
+               @[(t*)@]gb_alloc((long)((n)*@[sizeof@](t)),s)@]
+@z
+
 @x l.266
 char *gb_alloc(n,s)
   long n; /* number of consecutive bytes desired */
@@ -29,11 +75,19 @@ extern char *gb_alloc(); /* allocate another block for an area */
 extern void gb_free(); /* deallocate all blocks for an area */
 @y
 extern char *gb_alloc(long,Area); /* allocate another block for an area */
-#define gb_typed_alloc(n,t,s) @[@t\quad@>\
-               @[(t*)@]gb_alloc((long)((n)*@[sizeof@](t)),s)@]
 extern void gb_free(Area); /* deallocate all blocks for an area */
 @z
 
+@x l.427
+@d n_1 uu.I /* utility field |uu| may denote size of bipartite first part */
+
+@(gb_graph.h@>=
+#define n_1 @t\quad@> uu.I
+@y
+@(gb_graph.h@>=
+#define n_1 @t\quad@> uu.I /* utility field |uu| may denote size of bipartite first part */
+@z
+
 @x l.442
 Graph *gb_new_graph(n)
   long n; /* desired number of vertices */
@@ -115,6 +169,14 @@ void gb_new_arc(
   long len) /* its length */
 @z
 
+@x l.623
+@d gb_new_graph gb_nugraph /* abbreviations for Procrustean linkers */
+@d gb_new_arc gb_nuarc
+@d gb_new_edge gb_nuedge
+
+@y
+@z
+
 @x l.626
 void gb_new_edge(u,v,len)
   Vertex *u, *v; /* new arcs will go from |u| to |v| and from |v| to |u| */
@@ -188,6 +250,8 @@ extern void hash_setup(Graph *);
    /* create a hash table for a given graph */
 extern Vertex* hash_lookup(char *,Graph *);
    /* find a name in a given graph */
+@#
+#endif /* |GB_GRAPH_H| */
 @z
 
 @x l.855
diff --git a/PROTOTYPES/gb_io.ch b/PROTOTYPES/gb_io.ch
index 10429a7..8ba0e7d 100644
--- a/PROTOTYPES/gb_io.ch
+++ b/PROTOTYPES/gb_io.ch
@@ -1,15 +1,41 @@
-@x l.35
+@x l.34
+@t\2@>@/
 int main()
 @y
+@#
+@t\2\4@>
 int main(void)
 @z
 
+@x l.70
+@<Header files to include@>@;
+@y
+#include "gb_io.h" /* we include our own interface first */
+@z
+
+@x l.85
+@ @(gb_io.h@>=
+@<Header...@>@;
+@y
+@ @(gb_io.h@>=
+#ifndef GB_IO_H
+#define GB_IO_H
+@#
+@<Header files to include@>@;
+@z
+
 @x l.123
 static void fill_buf()
 @y
 static void fill_buf(void)
 @z
 
+@x l.182
+@d unexpected_char 127 /* default |icode| value */
+
+@y
+@z
+
 @x l.185
 static char *imap="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\
 abcdefghijklmnopqrstuvwxyz_^~&@@,;.:?!%#$+-*/|\\<=>()[]{}`'\" \n";
@@ -49,10 +75,12 @@ long imap_ord(
   return icode[c];
 @z
 
-@x l.206
+@x l.205
+#define unexpected_char @t\quad@> 127
 extern char imap_chr(); /* the character that maps to a given character */
 extern long imap_ord(); /* the ordinal number of a given character */
 @y
+#define unexpected_char @t\quad@> 127 /* default |icode| value */
 extern char imap_chr(long); /* the character that maps to a given character */
 extern long imap_ord(unsigned char); /* the ordinal number of a given character */
 @z
@@ -161,9 +189,12 @@ unsigned long gb_number(
     a=a*d+icode[(unsigned char)*cur_pos++];
 @z
 
-@x l.353
+@x l.352
+#define STR_BUF_LENGTH 160
+extern char str_buf[]; /* safe place to receive output of |gb_string| */
 extern char *gb_string(); /* |gb_string(p,c)| reads a string delimited by |c|
 @y
+extern char str_buf[]; /* safe place to receive output of |gb_string| */
 extern char *gb_string(char *,char);
   /* |gb_string(p,c)| reads a string delimited by |c|
 @z
@@ -178,6 +209,14 @@ char *gb_string(
   char c) /* character following the string */
 @z
 
+@x l.424
+@ @d gb_raw_open gb_r_open /* abbreviation for Procrustean external linkage */
+
+@(gb_io.h@>=
+@y
+@ @(gb_io.h@>=
+@z
+
 @x l.427
 extern void gb_raw_open(); /* open a file for GraphBase input */
 extern long gb_open(); /* open a GraphBase data file; return 0 if OK */
@@ -208,12 +247,22 @@ long gb_close()
 long gb_close(void)
 @z
 
+@x l.565
+@ @d gb_raw_close gb_r_close /* for Procrustean external linkage */
+
+@(gb_io.h@>=
+@y
+@ @(gb_io.h@>=
+@z
+
 @x l.567
 extern long gb_close(); /* close a GraphBase data file; return 0 if OK */
 extern long gb_raw_close(); /* close file and return the checksum */
 @y
 extern long gb_close(void); /* close a GraphBase data file; return 0 if OK */
 extern long gb_raw_close(void); /* close file and return the checksum */
+@#
+#endif /* |GB_IO_H| */
 @z
 
 @x l.571
diff --git a/PROTOTYPES/gb_lisa.ch b/PROTOTYPES/gb_lisa.ch
index 68b4630..161cf77 100644
--- a/PROTOTYPES/gb_lisa.ch
+++ b/PROTOTYPES/gb_lisa.ch
@@ -1,8 +1,17 @@
-@x l.21
+@x l.17
+@d plane_lisa p_lisa /* abbreviation for Procrustean external linkage */
+
+@(gb_lisa.h@>=
+#define plane_lisa p_lisa
 extern long* lisa();
 extern Graph *plane_lisa();
 extern Graph *bi_lisa();
 @y
+@(gb_lisa.h@>=
+#ifndef GB_LISA_H
+#define GB_LISA_H
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
+#define plane_lisa p_lisa
 extern long* lisa(unsigned long,unsigned long,unsigned long,@|
    unsigned long,unsigned long,unsigned long,unsigned long,@|
    unsigned long,unsigned long,Area);@/
@@ -14,6 +23,22 @@ extern Graph *bi_lisa(unsigned long,unsigned long,@|
    unsigned long,long);
 @z
 
+@x l.124
+extern char lisa_id[];
+@y
+extern char lisa_id[];
+@#
+#endif /* |GB_LISA_H| */
+@z
+
+@x l.142
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_lisa.h" /* we use our own interface first */
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+@z
+
 @x l.149
 long *lisa(m,n,d,m0,m1,n0,n1,d0,d1,area)
   unsigned long m,n; /* number of rows and columns desired */
@@ -163,6 +188,17 @@ for (i=0;i<(long)m0;i++)
     /* lower and upper threshold of raw pixel scores */
 @z
 
+@x l.431
+@ @<gb_lisa.h@>=
+#define pixel_value @t\quad@> x.I /* definitions for the header file */
+#define first_pixel @t\quad@> y.I
+#define last_pixel @t\quad@> z.I
+#define matrix_rows @t\quad@> uu.I
+#define matrix_cols @t\quad@> vv.I
+@y
+@ (This section remains empty for historic reasons.)
+@z
+
 @x l.496
     if (k<m) {
 @y
diff --git a/PROTOTYPES/gb_miles.ch b/PROTOTYPES/gb_miles.ch
index 5001e35..20d64af 100644
--- a/PROTOTYPES/gb_miles.ch
+++ b/PROTOTYPES/gb_miles.ch
@@ -1,10 +1,31 @@
 @x l.14
 extern Graph *miles();
 @y
+#ifndef GB_MILES_H
+#define GB_MILES_H
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
 extern Graph *miles(unsigned long,long,long,long,@|
   unsigned long,unsigned long,long);
 @z
 
+@x l.63
+@d MAX_N 128
+
+@y
+@z
+
+@x l.107
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_miles.h" /* we use our own interface first */
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+@z
+
 @x l.116
 Graph *miles(n,north_weight,west_weight,pop_weight,
     max_distance,max_degree,seed)
@@ -27,6 +48,14 @@ Graph *miles(
   long seed) /* random number seed */
 @z
 
+@x l.303
+@d x_coord x.I
+@d y_coord y.I
+@d index_no z.I
+@d people w.I
+@y
+@z
+
 @x l.366
       if (j>max_distance)
 @y
@@ -51,4 +80,6 @@ Graph *miles(
 extern long miles_distance();
 @y
 extern long miles_distance(Vertex *,Vertex *);
+@#
+#endif /* |GB_MILES_H| */
 @z
diff --git a/PROTOTYPES/gb_plane.ch b/PROTOTYPES/gb_plane.ch
index 3f0ae70..06fea42 100644
--- a/PROTOTYPES/gb_plane.ch
+++ b/PROTOTYPES/gb_plane.ch
@@ -1,13 +1,40 @@
-@x l.20
+@x l.16
+@d plane_miles p_miles /* abbreviation for Procrustean external linkage */
+
+@(gb_plane.h@>=
+#define plane_miles p_miles
 extern Graph *plane();
 extern Graph *plane_miles();
 extern void delaunay();
 @y
+@(gb_plane.h@>=
+#ifndef GB_PLANE_H
+#define GB_PLANE_H
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
+#define plane_miles p_miles /* abbreviation for Procrustean external linkage */
 extern Graph *plane(unsigned long,unsigned long,unsigned long,@|
   unsigned long,unsigned long,long);
 extern Graph *plane_miles(unsigned long,long,long,long,@|
   unsigned long,unsigned long,long);
 extern void delaunay(Graph *,void (*)(Vertex *,Vertex *));
+#endif /* |GB_PLANE_H| */
+@z
+
+@x l.61
+@(gb_plane.h@>=
+#define INFTY @t\quad@> 0x10000000L
+
+@y
+@z
+
+@x l.76
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_plane.h" /* we use our own interface first */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
 @z
 
 @x l.92
@@ -37,6 +64,15 @@ for (k=0,v=new_graph->vertices; k<n; k++,v++) {
 for (k=0,v=new_graph->vertices; k<(long)n; k++,v++) {
 @z
 
+@x l.149
+@ @(gb_plane.h@>=
+#define x_coord @t\quad@> x.I
+#define y_coord @t\quad@> y.I
+#define z_coord @t\quad@> z.I
+@y
+@ (This section remains empty for historic reasons.)
+@z
+
 @x l.226
 void delaunay(g,f)
   Graph *g; /* vertices in the plane */
diff --git a/PROTOTYPES/gb_raman.ch b/PROTOTYPES/gb_raman.ch
index 8b06e79..4bbb542 100644
--- a/PROTOTYPES/gb_raman.ch
+++ b/PROTOTYPES/gb_raman.ch
@@ -1,7 +1,17 @@
 @x l.32
 extern Graph *raman();
 @y
+#ifndef GB_RAMAN_H
+#define GB_RAMAN_H
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
 extern Graph *raman(long,long,unsigned long,unsigned long);
+#endif /* | GB_RAMAN_H| */
+@z
+
+@x l.87
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_raman.h" /* we use our own interface first */
 @z
 
 @x l.92
diff --git a/PROTOTYPES/gb_rand.ch b/PROTOTYPES/gb_rand.ch
index 543779d..c06d4bf 100644
--- a/PROTOTYPES/gb_rand.ch
+++ b/PROTOTYPES/gb_rand.ch
@@ -1,3 +1,16 @@
+@x l.22
+@d random_graph r_graph /* abbreviations for Procrustean external linkage */
+@d random_bigraph r_bigraph
+@d random_lengths r_lengths
+
+@(gb_rand.h@>=
+@y
+@(gb_rand.h@>=
+#ifndef GB_RAND_H
+#define GB_RAND_H
+#include "gb_graph.h" /* this header file teaches \CEE/ about GraphBase */
+@z
+
 @x l.31
 extern Graph *random_graph();
 extern Graph *random_bigraph();
@@ -8,6 +21,13 @@ extern Graph *random_graph(unsigned long,unsigned long,long,long,long,@|
 extern Graph *random_bigraph(unsigned long,unsigned long,unsigned long,@|
   long,long *,long *,long,long,long);
 extern long random_lengths(Graph *,long,long,long,long *,long);
+#endif /* |GB_RAND_H| */
+@z
+
+@x l.39
+#include "gb_graph.h" /* this header file teaches \CEE/ about GraphBase */
+@y
+#include "gb_rand.h" /* we include our own interface first */
 @z
 
 @x l.139
diff --git a/PROTOTYPES/gb_roget.ch b/PROTOTYPES/gb_roget.ch
index 4bcd4cb..5822402 100644
--- a/PROTOTYPES/gb_roget.ch
+++ b/PROTOTYPES/gb_roget.ch
@@ -1,9 +1,25 @@
 @x l.14
 extern Graph *roget();
 @y
+#ifndef GB_ROGET_H
+#define GB_ROGET_H
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
 extern Graph *roget(unsigned long,unsigned long,unsigned long,long);
 @z
 
+@x l.70
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+#include "gb_graph.h"
+ /* and we will use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_roget.h" /* we use our own interface first */
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+@z
+
 @x l.78
 Graph *roget(n,min_distance,prob,seed)
   unsigned long n; /* number of vertices desired */
@@ -20,12 +36,28 @@ Graph *roget(
   long seed) /* random number seed */
 @z
 
+@x l.170
+@d cat_no u.I /* utility field |u| of each vertex holds the category number */
+
+@y
+@z
+
 @x l.176
     if (gb_number(10)!=k) panic(syntax_error); /* out of synch */
 @y
     if ((long)gb_number(10)!=k) panic(syntax_error); /* out of synch */
 @z
 
+@x l.188
+#define cat_no @t\quad@> u.I
+ /* definition of |cat_no| is repeated in the header file */
+@y
+#define cat_no @t\quad@> u.I
+  /* utility field |u| of each vertex holds the category number */
+@#
+#endif /* |GB_ROGET_H| */
+@z
+
 @x l.198
   if (mapping[j] && iabs(j-k)>=min_distance &&
        (prob==0 || ((gb_next_rand()>>15)>=prob)))
@@ -38,6 +70,6 @@ Graph *roget(
     /* fall through to the space case */
   case ' ': j=gb_number(10);@+break;
 @y
-    @=/* fall through */@>
+    @=/* fall through */@>@;
   case ' ': j=gb_number(10);@+break;
 @z
diff --git a/PROTOTYPES/gb_save.ch b/PROTOTYPES/gb_save.ch
index 7ee88b3..62f3d83 100644
--- a/PROTOTYPES/gb_save.ch
+++ b/PROTOTYPES/gb_save.ch
@@ -1,9 +1,24 @@
-@x l.47
+@x l.46
+@(gb_save.h@>=
 extern long save_graph();
 extern Graph *restore_graph();
 @y
+@(gb_save.h@>=
+#ifndef GB_SAVE_H
+#define GB_SAVE_H
+#include "gb_graph.h" /* we use the data structures of {\sc GB\_\,GRAPH} */
 extern long save_graph(Graph *,char *);
 extern Graph *restore_graph(char *);
+#endif /* |GB_SAVE_H| */
+@z
+
+@x l.54
+#include "gb_io.h" /* we use the input/output conventions of {\sc GB\_\,IO} */
+#include "gb_graph.h"
+ /* and, of course, the data structures of {\sc GB\_\,GRAPH} */
+@y
+#include "gb_save.h" /* we use our own interface first */
+#include "gb_io.h" /* we use the input/output conventions of {\sc GB\_\,IO} */
 @z
 
 @x l.149
@@ -108,6 +123,6 @@ static void translate_field(
     /* fall through to case \.Z */
  case 'Z': buf_ptr--; /* forget spurious comma */
 @y
-    @=/* fall through */@>
+    @=/* fall through */@>@;
  case 'Z': buf_ptr--; /* forget spurious comma */
 @z
diff --git a/PROTOTYPES/gb_sort.ch b/PROTOTYPES/gb_sort.ch
index 32a637d..05873d4 100644
--- a/PROTOTYPES/gb_sort.ch
+++ b/PROTOTYPES/gb_sort.ch
@@ -1,7 +1,27 @@
-@x l.75
+@x l.10
+#include <stdio.h> /* the \.{NULL} pointer (|NULL|) is defined here */
+@y
+#include "gb_sort.h" /* we use our own interface first */
+#include <stdio.h> /* the \.{NULL} pointer (|NULL|) is defined here */
+@z
+
+@x l.69
+@ In the header file, |gb_sorted| is declared to be
+an array of pointers to |char|, since
+nodes may have different types in different applications. User programs
+should cast |gb_sorted| to the appropriate type as in the example above.
+
+@(gb_sort.h@>=
 extern void gb_linksort(); /* procedure to sort a linked list */
+extern char* gb_sorted[]; /* the results of |gb_linksort| */
 @y
-extern void gb_linksort(void *); /* procedure to sort a linked list */
+@ @(gb_sort.h@>=
+#ifndef GB_SORT_H
+#define GB_SORT_H
+typedef struct node_struct node;
+extern void gb_linksort(node *); /* procedure to sort a linked list */
+extern node* gb_sorted[]; /* the results of |gb_linksort| */
+#endif /* |GB_SORT_H| */
 @z
 
 @x l.95
diff --git a/PROTOTYPES/gb_words.ch b/PROTOTYPES/gb_words.ch
index 254dc90..73355ff 100644
--- a/PROTOTYPES/gb_words.ch
+++ b/PROTOTYPES/gb_words.ch
@@ -2,10 +2,25 @@
 extern Graph *words();
 extern Vertex *find_word();
 @y
+#ifndef GB_WORDS_H
+#define GB_WORDS_H
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
 extern Graph *words(unsigned long,long [],long,long);
 extern Vertex *find_word(char *,void (*)(Vertex *));
 @z
 
+@x l.152
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+#include "gb_graph.h" /* we will use the {\sc GB\_\,GRAPH} data structures */
+@y
+#include "gb_words.h" /* we use our own interface first */
+#include "gb_io.h" /* we will use the {\sc GB\_\,IO} routines for input */
+#include "gb_flip.h"
+ /* we will use the {\sc GB\_\,FLIP} routines for random numbers */
+@z
+
 @x l.162
 Graph *words(n,wt_vector,wt_threshold,seed)
   unsigned long n; /* maximum number of vertices desired */
@@ -48,6 +63,21 @@ static long iabs(
   } while (gb_char()==',');
 @z
 
+@x l.418
+@d weight u.I /* weighted frequencies */
+@d loc a.I /* index of difference (0, 1, 2, 3, or 4) */
+
+@(gb_words.h@>=
+#define weight @[u.I@] /* repeat the definitions in the header file */
+#define loc @[a.I@]
+@y
+@(gb_words.h@>=
+#define weight @[u.I@] /* weighted frequencies */
+#define loc @[a.I@] /* index of difference (0, 1, 2, 3, or 4) */
+@#
+#endif /* |GB_WORDS_H| */
+@z
+
 @x l.426
 if (n==0 || nn<n)
 @y
diff --git a/PROTOTYPES/test_sample.ch b/PROTOTYPES/test_sample.ch
index f04eca8..634dd62 100644
--- a/PROTOTYPES/test_sample.ch
+++ b/PROTOTYPES/test_sample.ch
@@ -1,9 +1,23 @@
+@x l.26
+#include "gb_graph.h" /* we use the {\sc GB\_\,GRAPH} data structures */
+#include "gb_io.h" /* and the GraphBase input/output routines */
+@y
+@z
+
 @x l.32
 @t\4@>int main()
 @y
 int main(void)
 @z
 
+@x l.45
+#include "gb_gates.h" /* and the graphs based on logic circuits */
+@y
+#include "gb_gates.h" /* and the graphs based on logic circuits */
+#include "gb_graph.h" /* we use the {\sc GB\_\,GRAPH} data structures */
+#include "gb_io.h" /* and the GraphBase input/output routines */
+@z
+
 @x l.113
 if (i=random_lengths(g,0L,10L,12L,dst,2L))
 @y
-- 
2.51.0

